#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.11"
# dependencies = [
#     "pyyaml",
# ]
# ///
import pprint
from io import TextIOWrapper
from types import SimpleNamespace
from typing import Union, Callable
from yaml import load, dump
try:
    from yaml import CLoader as Loader, CDumper as Dumper
except ImportError:
    from yaml import Loader, Dumper


TreeNode = SimpleNamespace


def depth_first(tree: any, callback: Callable[[any], any]) -> any:
    if isinstance(tree, list):
        return [depth_first(node, callback) for node in tree]
    elif isinstance(tree, dict):
        return {key: depth_first(node, callback) for key, node in tree.items()}
    else:
        return callback(tree)


def is_computed(node: any) -> bool:
    return isinstance(node, str) and ':=' in node


def find_computed_nodes(tree: any) -> list[str]:
    nodes = []

    def callback(n):
        if is_computed(n):
            nodes.append(n)
        return n
    depth_first(tree, callback)
    return nodes


def to_treenode(tree: any) -> TreeNode:
    if isinstance(tree, dict):
        return TreeNode(**{key: to_treenode(val) for key, val in tree.items()})
    return tree


def to_raw(tree: any) -> any:
    if isinstance(tree, TreeNode):
        return {key: to_raw(val) for key, val in tree.__dict__.items()}
    return tree


def load_yaml(file: TextIOWrapper) -> TreeNode:
    data: any = load(file, Loader=Loader)
    return to_treenode(data)


def save_yaml(data: TreeNode, file: TextIOWrapper):
    file.seek(0)
    file.truncate(0)
    dump(to_raw(data), file, Dumper=Dumper, sort_keys=False)


def main() -> None:
    with open("test.yml", "r+") as f:
        data = load_yaml(f)

        pprint.pp(data)

        save_yaml(data, f)


if __name__ == "__main__":
    main()
