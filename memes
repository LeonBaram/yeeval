#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.11"
# dependencies = [
#     "pyyaml",
# ]
# ///
import pprint
from io import TextIOWrapper
from types import SimpleNamespace
from typing import Union, Callable
from yaml import load, dump
try:
    from yaml import CLoader as Loader, CDumper as Dumper
except ImportError:
    from yaml import Loader, Dumper


TreeNode = Union[int, float, str, bool,
                 list['TreeNode'], dict[str, 'TreeNode']]


def depth_first(tree: TreeNode, callback: Callable[[TreeNode], TreeNode]) -> TreeNode:
    if isinstance(tree, list):
        return [depth_first(node, callback) for node in tree]
    elif isinstance(tree, dict):
        return {key: depth_first(node, callback) for key, node in tree.items()}
    else:
        return callback(tree)


def is_computed(node: TreeNode) -> bool:
    return isinstance(node, str) and ':=' in node


def find_computed_nodes(tree: TreeNode) -> list[str]:
    nodes = []

    def callback(n):
        if is_computed(n):
            nodes.append(n)
        return n
    depth_first(tree, callback)
    return nodes


def to_namespace(tree: TreeNode) -> SimpleNamespace:
    if isinstance(tree, dict):
        return SimpleNamespace(**{key: to_namespace(val) for key, val in tree.items()})
    return tree


def from_namespace(tree) -> TreeNode:
    if isinstance(tree, SimpleNamespace):
        return {key: from_namespace(val) for key, val in tree.__dict__.items()}
    return tree


def load_yaml(file: TextIOWrapper) -> SimpleNamespace:
    data: TreeNode = load(file, Loader=Loader)
    return to_namespace(data)


def save_yaml(data: SimpleNamespace, file: TextIOWrapper):
    file.seek(0)
    file.truncate(0)
    dump(from_namespace(data), file, Dumper=Dumper, sort_keys=False)


def main() -> None:
    with open("test.yml", "r+") as f:
        data = load_yaml(f)

        pprint.pp(data)

        save_yaml(data, f)


if __name__ == "__main__":
    main()
